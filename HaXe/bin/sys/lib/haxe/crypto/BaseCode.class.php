<?php

// Generated by Haxe 3.4.7
class haxe_crypto_BaseCode {
	public function __construct($base) {
		if(!php_Boot::$skip_constructor) {
		$len = $base->length;
		$nbits = 1;
		while($len > 1 << $nbits) {
			$nbits = $nbits + 1;
		}
		$tmp = null;
		if($nbits <= 8) {
			$tmp = $len !== 1 << $nbits;
		} else {
			$tmp = true;
		}
		if($tmp) {
			throw new HException("BaseCode : base length must be a power of two.");
		}
		$this->base = $base;
		$this->nbits = $nbits;
	}}
	public $base;
	public $nbits;
	public $tbl;
	public function encodeBytes($b) {
		$nbits = $this->nbits;
		$base = $this->base;
		$size = Std::int($b->length * 8 / $nbits);
		$out = null;
		if(_hx_mod($b->length * 8, $nbits) === 0) {
			$out = 0;
		} else {
			$out = 1;
		}
		$out1 = haxe_io_Bytes::alloc($size + $out);
		$buf = 0;
		$curbits = 0;
		$mask = (1 << $nbits) - 1;
		$pin = 0;
		$pout = 0;
		while($pout < $size) {
			while($curbits < $nbits) {
				$curbits = $curbits + 8;
				$buf = $buf << 8;
				$pin = $pin + 1;
				$pos = $pin - 1;
				$this1 = $b->b;
				$buf = $buf | ord($this1->s[$pos]);
				unset($this1,$pos);
			}
			$curbits = $curbits - $nbits;
			{
				$pout = $pout + 1;
				$pos1 = $pout - 1;
				$this2 = $base->b;
				$v = ord($this2->s[$buf >> $curbits & $mask]);
				{
					$this3 = $out1->b;
					$this3->s[$pos1] = chr($v);
					unset($this3);
				}
				unset($v,$this2,$pos1);
			}
		}
		if($curbits > 0) {
			$pout = $pout + 1;
			$pos2 = $pout - 1;
			$this4 = $base->b;
			$v1 = ord($this4->s[$buf << $nbits - $curbits & $mask]);
			{
				$this5 = $out1->b;
				$this5->s[$pos2] = chr($v1);
			}
		}
		return $out1;
	}
	public function initTable() {
		$tbl = new _hx_array(array());
		{
			$_g = 0;
			while($_g < 256) {
				$_g = $_g + 1;
				$i = $_g - 1;
				$tbl[$i] = -1;
				unset($i);
			}
		}
		{
			$_g1 = 0;
			$_g2 = $this->base->length;
			while($_g1 < $_g2) {
				$_g1 = $_g1 + 1;
				$i1 = $_g1 - 1;
				$this1 = $this->base->b;
				$tbl[ord($this1->s[$i1])] = $i1;
				unset($this1,$i1);
			}
		}
		$this->tbl = $tbl;
	}
	public function decodeBytes($b) {
		$nbits = $this->nbits;
		$base = $this->base;
		if($this->tbl === null) {
			$this->initTable();
		}
		$tbl = $this->tbl;
		$size = $b->length * $nbits >> 3;
		$out = haxe_io_Bytes::alloc($size);
		$buf = 0;
		$curbits = 0;
		$pin = 0;
		$pout = 0;
		while($pout < $size) {
			while($curbits < 8) {
				$curbits = $curbits + $nbits;
				$buf = $buf << $nbits;
				$pin = $pin + 1;
				$pos = $pin - 1;
				$this1 = $b->b;
				$i = $tbl[ord($this1->s[$pos])];
				if($i === -1) {
					throw new HException("BaseCode : invalid encoded char");
				}
				$buf = $buf | $i;
				unset($this1,$pos,$i);
			}
			$curbits = $curbits - 8;
			{
				$pout = $pout + 1;
				$pos1 = $pout - 1;
				{
					$this2 = $out->b;
					$this2->s[$pos1] = chr($buf >> $curbits & 255);
					unset($this2);
				}
				unset($pos1);
			}
		}
		return $out;
	}
	public function __call($m, $a) {
		if(isset($this->$m) && is_callable($this->$m))
			return call_user_func_array($this->$m, $a);
		else if(isset($this->__dynamics[$m]) && is_callable($this->__dynamics[$m]))
			return call_user_func_array($this->__dynamics[$m], $a);
		else if('toString' == $m)
			return $this->__toString();
		else
			throw new HException('Unable to call <'.$m.'>');
	}
	function __toString() { return 'haxe.crypto.BaseCode'; }
}
