<?php

// Generated by Haxe 3.4.7
class jotun_serial_JsonTool {
	public function __construct($replacer, $space) {
		if(!php_Boot::$skip_constructor) {
		$this->replacer = $replacer;
		$this->indent = $space;
		$this->pretty = $space !== null;
		$this->nind = 0;
		$this->buf = new StringBuf();
	}}
	public $buf;
	public $replacer;
	public $indent;
	public $pretty;
	public $nind;
	public function ipad() {
		if($this->pretty) {
			$c = $this->indent;
			$l = $this->nind * strlen($this->indent);
			$v = null;
			$v1 = null;
			if(strlen($c) !== 0) {
				$v1 = strlen("") >= $l;
			} else {
				$v1 = true;
			}
			if($v1) {
				$v = "";
			} else {
				$v = str_pad("", Math::ceil(($l - strlen("")) / strlen($c)) * strlen($c) + strlen(""), $c, STR_PAD_LEFT);
			}
			$this->buf->add($v);
		}
	}
	public function newl() {
		if($this->pretty) {
			$_this = $this->buf;
			$_this->b = _hx_string_or_null($_this->b) . "\x0A";
		}
	}
	public function write($k, $v) {
		if($this->replacer !== null) {
			$v = $this->replacer($k, $v);
		}
		{
			$_g = Type::typeof($v);
			switch($_g->index) {
			case 0:{
				$this->buf->add("null");
			}break;
			case 1:{
				$this->buf->add($v);
			}break;
			case 2:{
				$v1 = null;
				if(Math::isFinite($v)) {
					$v1 = $v;
				} else {
					$v1 = "null";
				}
				$this->buf->add($v1);
			}break;
			case 3:{
				$tmp = null;
				if($v) {
					$tmp = "true";
				} else {
					$tmp = "false";
				}
				$this->buf->add($tmp);
			}break;
			case 4:{
				$this->fieldsString($v, Reflect::fields($v));
			}break;
			case 5:{
				$this->buf->add("\"<fun>\"");
			}break;
			case 6:{
				$c = _hx_deref($_g)->params[0];
				if((is_object($_t = $c) && ($_t instanceof Enum) ? $_t == _hx_qtype("String") : _hx_equal($_t, _hx_qtype("String")))) {
					$this->quote($v);
				} else {
					if((is_object($_t2 = $c) && ($_t2 instanceof Enum) ? $_t2 == _hx_qtype("Array") : _hx_equal($_t2, _hx_qtype("Array")))) {
						$v2 = $v;
						{
							$_this = $this->buf;
							$_this->b = _hx_string_or_null($_this->b) . "[";
						}
						$len = $v2->length;
						$last = $len - 1;
						{
							$_g1 = 0;
							$_g2 = $len;
							while($_g1 < $_g2) {
								$_g1 = $_g1 + 1;
								$i = $_g1 - 1;
								if($i > 0) {
									$_this1 = $this->buf;
									$_this1->b = _hx_string_or_null($_this1->b) . ",";
									unset($_this1);
								} else {
									$this->nind++;
								}
								if($this->pretty) {
									$_this2 = $this->buf;
									$_this2->b = _hx_string_or_null($_this2->b) . "\x0A";
									unset($_this2);
								}
								if($this->pretty) {
									$c1 = $this->indent;
									$l = $this->nind * strlen($this->indent);
									$v3 = null;
									$v4 = null;
									if(strlen($c1) !== 0) {
										$v4 = strlen("") >= $l;
									} else {
										$v4 = true;
									}
									if($v4) {
										$v3 = "";
									} else {
										$v3 = str_pad("", Math::ceil(($l - strlen("")) / strlen($c1)) * strlen($c1) + strlen(""), $c1, STR_PAD_LEFT);
									}
									$this->buf->add($v3);
									unset($v4,$v3,$l,$c1);
								}
								$this->write($i, $v2[$i]);
								if($i === $last) {
									$this->nind--;
									if($this->pretty) {
										$_this3 = $this->buf;
										$_this3->b = _hx_string_or_null($_this3->b) . "\x0A";
										unset($_this3);
									}
									if($this->pretty) {
										$c2 = $this->indent;
										$l1 = $this->nind * strlen($this->indent);
										$v5 = null;
										$v6 = null;
										if(strlen($c2) !== 0) {
											$v6 = strlen("") >= $l1;
										} else {
											$v6 = true;
										}
										if($v6) {
											$v5 = "";
										} else {
											$v5 = str_pad("", Math::ceil(($l1 - strlen("")) / strlen($c2)) * strlen($c2) + strlen(""), $c2, STR_PAD_LEFT);
										}
										$this->buf->add($v5);
										unset($v6,$v5,$l1,$c2);
									}
								}
								unset($i);
							}
						}
						{
							$_this4 = $this->buf;
							$_this4->b = _hx_string_or_null($_this4->b) . "]";
						}
					} else {
						if((is_object($_t3 = $c) && ($_t3 instanceof Enum) ? $_t3 == _hx_qtype("haxe.ds.StringMap") : _hx_equal($_t3, _hx_qtype("haxe.ds.StringMap")))) {
							$v7 = $v;
							$o = _hx_anonymous(array());
							{
								$k1 = $v7->keys();
								while($k1->hasNext()) {
									$k2 = $k1->next();
									$value = $v7->get($k2);
									$o->{$k2} = $value;
									unset($value,$k2);
								}
							}
							$this->fieldsString($o, Reflect::fields($o));
						} else {
							if((is_object($_t4 = $c) && ($_t4 instanceof Enum) ? $_t4 == _hx_qtype("Date") : _hx_equal($_t4, _hx_qtype("Date")))) {
								$v8 = $v;
								$this->quote($v8->toString());
							} else {
								$this->fieldsString($v, Reflect::fields($v));
							}
						}
					}
				}
			}break;
			case 7:{
				$i1 = $v->index;
				$this->buf->add($i1);
			}break;
			case 8:{
				$this->fieldsString($v, Reflect::fields($v));
			}break;
			}
		}
	}
	public function objString($v) {
		$this->fieldsString($v, Reflect::fields($v));
	}
	public function fieldsString($v, $fields) {
		{
			$_this = $this->buf;
			$_this->b = _hx_string_or_null($_this->b) . "{";
		}
		$len = $fields->length;
		$last = $len - 1;
		$first = true;
		{
			$_g1 = 0;
			$_g = $len;
			while($_g1 < $_g) {
				$_g1 = $_g1 + 1;
				$i = $_g1 - 1;
				$f = $fields[$i];
				$value = Reflect::field($v, $f);
				if($value === null) {
					continue;
				}
				if(Reflect::isFunction($value)) {
					continue;
				}
				$tmp = null;
				if(Std::is($f, _hx_qtype("String"))) {
					$tmp = _hx_substr($f, 0, 1) === "_";
				} else {
					$tmp = false;
				}
				if($tmp) {
					continue;
				}
				if($first) {
					$this->nind++;
					$first = false;
				} else {
					$_this1 = $this->buf;
					$_this1->b = _hx_string_or_null($_this1->b) . ",";
					unset($_this1);
				}
				if($this->pretty) {
					$_this2 = $this->buf;
					$_this2->b = _hx_string_or_null($_this2->b) . "\x0A";
					unset($_this2);
				}
				if($this->pretty) {
					$c = $this->indent;
					$l = $this->nind * strlen($this->indent);
					$v1 = null;
					$v2 = null;
					if(strlen($c) !== 0) {
						$v2 = strlen("") >= $l;
					} else {
						$v2 = true;
					}
					if($v2) {
						$v1 = "";
					} else {
						$v1 = str_pad("", Math::ceil(($l - strlen("")) / strlen($c)) * strlen($c) + strlen(""), $c, STR_PAD_LEFT);
					}
					$this->buf->add($v1);
					unset($v2,$v1,$l,$c);
				}
				$this->quote($f);
				{
					$_this3 = $this->buf;
					$_this3->b = _hx_string_or_null($_this3->b) . ":";
					unset($_this3);
				}
				if($this->pretty) {
					$_this4 = $this->buf;
					$_this4->b = _hx_string_or_null($_this4->b) . " ";
					unset($_this4);
				}
				$this->write($f, $value);
				if($i === $last) {
					$this->nind--;
					if($this->pretty) {
						$_this5 = $this->buf;
						$_this5->b = _hx_string_or_null($_this5->b) . "\x0A";
						unset($_this5);
					}
					if($this->pretty) {
						$c1 = $this->indent;
						$l1 = $this->nind * strlen($this->indent);
						$v3 = null;
						$v4 = null;
						if(strlen($c1) !== 0) {
							$v4 = strlen("") >= $l1;
						} else {
							$v4 = true;
						}
						if($v4) {
							$v3 = "";
						} else {
							$v3 = str_pad("", Math::ceil(($l1 - strlen("")) / strlen($c1)) * strlen($c1) + strlen(""), $c1, STR_PAD_LEFT);
						}
						$this->buf->add($v3);
						unset($v4,$v3,$l1,$c1);
					}
				}
				unset($value,$tmp,$i,$f);
			}
		}
		{
			$_this6 = $this->buf;
			$_this6->b = _hx_string_or_null($_this6->b) . "}";
		}
	}
	public function quote($s) {
		$s1 = strlen($s);
		if($s1 !== haxe_Utf8::length($s)) {
			$this->quoteUtf8($s);
			return;
		}
		{
			$_this = $this->buf;
			$_this->b = _hx_string_or_null($_this->b) . "\"";
		}
		$i = 0;
		while(true) {
			$i = $i + 1;
			$c = ord(substr($s,$i - 1,1));
			if(($c === 0)) {
				break;
			}
			switch($c) {
			case 8:{
				$this->buf->add("\\b");
			}break;
			case 9:{
				$this->buf->add("\\t");
			}break;
			case 10:{
				$this->buf->add("\\n");
			}break;
			case 12:{
				$this->buf->add("\\f");
			}break;
			case 13:{
				$this->buf->add("\\r");
			}break;
			case 34:{
				$this->buf->add("\\\"");
			}break;
			case 92:{
				$this->buf->add("\\\\");
			}break;
			default:{
				$_this1 = $this->buf;
				$_this1->b = _hx_string_or_null($_this1->b) . _hx_string_or_null(chr($c));
			}break;
			}
			unset($c);
		}
		{
			$_this2 = $this->buf;
			$_this2->b = _hx_string_or_null($_this2->b) . "\"";
		}
	}
	public function quoteUtf8($s) {
		$u = new haxe_Utf8(null);
		haxe_Utf8::iter($s, array(new _hx_lambda(array(&$u), "jotun_serial_JsonTool_0"), 'execute'));
		$this->buf->add("\"");
		$tmp = $this->buf;
		$tmp->add($u->toString());
		$this->buf->add("\"");
	}
	public function __call($m, $a) {
		if(isset($this->$m) && is_callable($this->$m))
			return call_user_func_array($this->$m, $a);
		else if(isset($this->__dynamics[$m]) && is_callable($this->__dynamics[$m]))
			return call_user_func_array($this->__dynamics[$m], $a);
		else if('toString' == $m)
			return $this->__toString();
		else
			throw new HException('Unable to call <'.$m.'>');
	}
	static function customReplacer($a, $b) { return call_user_func_array(self::$customReplacer, array($a, $b)); }
	public static $customReplacer = null;
	static function stringfy($o, $replacer = null, $space = null) {
		$printer = null;
		if($replacer !== null) {
			$printer = $replacer;
		} else {
			$printer = (property_exists("jotun_serial_JsonTool", "customReplacer") ? jotun_serial_JsonTool::$customReplacer: array("jotun_serial_JsonTool", "customReplacer"));
		}
		$printer1 = new jotun_serial_JsonTool($printer, $space);
		$printer1->write("", $o);
		return $printer1->buf->b;
	}
	function __toString() { return 'jotun.serial.JsonTool'; }
}
jotun_serial_JsonTool::$customReplacer = array(new _hx_lambda(array(), "jotun_serial_JsonTool_1"), 'execute');
function jotun_serial_JsonTool_0(&$u, $c) {
	{
		switch($c) {
		case 8:{
			$u->addChar(92);
			$u->addChar(98);
		}break;
		case 9:{
			$u->addChar(92);
			$u->addChar(116);
		}break;
		case 10:{
			$u->addChar(92);
			$u->addChar(110);
		}break;
		case 12:{
			$u->addChar(92);
			$u->addChar(102);
		}break;
		case 13:{
			$u->addChar(92);
			$u->addChar(114);
		}break;
		case 34:case 92:{
			$u->addChar(92);
			$u->addChar($c);
		}break;
		default:{
			$u->addChar($c);
		}break;
		}
	}
}
function jotun_serial_JsonTool_1($a, $b) {
	{
		if(Std::is($a, _hx_qtype("String"))) {
			if(_hx_equal(_hx_string_call($a, "substr", array(0, 1)), "_")) {
				return null;
			}
		}
		if(Std::is($b, _hx_qtype("jotun.tools.Flag"))) {
			return _hx_field($b, "value");
		}
		if($b === null) {
			return null;
		} else {
			return $b;
		}
	}
}
