<?php

// Generated by Haxe 3.4.7
class sirius_tools_Flag {
	public function __construct($value) {
		if(!php_Boot::$skip_constructor) {
		$tmp = null;
		if(!Std::is($value, _hx_qtype("Float"))) {
			$tmp = Std::is($value, _hx_qtype("Int"));
		} else {
			$tmp = false;
		}
		if($tmp) {
			$value = Std::parseInt($value);
		}
		$this->value = _hx_shift_right($value, 0);
	}}
	public $value;
	public function toggle($bit) {
		$this->value = sirius_tools_Flag::FToggle($this->value, $bit);
		return $this;
	}
	public function put($bit) {
		$this->value = sirius_tools_Flag::FPut($this->value, 1 << $bit);
		return $this;
	}
	public function drop($bit) {
		$this->value = sirius_tools_Flag::FDrop($this->value, 1 << $bit);
		return $this;
	}
	public function test($bit) {
		return sirius_tools_Flag::FTest($this->value, 1 << $bit);
	}
	public function putAll($bits) {
		$_gthis = $this;
		sirius_utils_Dice::Values($bits, array(new _hx_lambda(array(&$_gthis), "sirius_tools_Flag_0"), 'execute'), null);
		return $this;
	}
	public function dropAll($bits) {
		$_gthis = $this;
		sirius_utils_Dice::Values($bits, array(new _hx_lambda(array(&$_gthis), "sirius_tools_Flag_1"), 'execute'), null);
		return $this;
	}
	public function testAll($bits) {
		$_gthis = $this;
		return sirius_utils_Dice::Values($bits, array(new _hx_lambda(array(&$_gthis), "sirius_tools_Flag_2"), 'execute'), null)->completed;
	}
	public function testAny($bits, $min = null) {
		if($min === null) {
			$min = 1;
		}
		$_gthis = $this;
		return !sirius_utils_Dice::Values($bits, array(new _hx_lambda(array(&$_gthis, &$min), "sirius_tools_Flag_3"), 'execute'), null)->completed;
	}
	public function length() {
		return sirius_tools_Flag::FLength($this->value);
	}
	public function toString($skip = null) {
		if($skip === null) {
			$skip = 0;
		}
		return sirius_tools_Flag::FValue($this->value, $skip);
	}
	public function __call($m, $a) {
		if(isset($this->$m) && is_callable($this->$m))
			return call_user_func_array($this->$m, $a);
		else if(isset($this->__dynamics[$m]) && is_callable($this->__dynamics[$m]))
			return call_user_func_array($this->__dynamics[$m], $a);
		else if('toString' == $m)
			return $this->__toString();
		else
			throw new HException('Unable to call <'.$m.'>');
	}
	static function from($hash) {
		if(Std::is($hash, _hx_qtype("String"))) {
			$hash = Std::parseInt($hash);
		}
		return new sirius_tools_Flag($hash);
	}
	static function FPut($hash, $bit) {
		return $hash | $bit;
	}
	static function FDrop($hash, $bit) {
		return $hash & ~$bit;
	}
	static function FToggle($hash, $bit) {
		if(sirius_tools_Flag::FTest($hash, $bit)) {
			return sirius_tools_Flag::FDrop($hash, $bit);
		} else {
			return sirius_tools_Flag::FPut($hash, $bit);
		}
	}
	static function FTest($hash, $value) {
		return ($hash & $value) === $value;
	}
	static function FValue($hash, $skip = null) {
		if($skip === null) {
			$skip = 0;
		}
		$v = _hx_string_call($hash, "toString", array(2));
		$i = strlen($v);
		while(true) {
			$aNeg = 32 < 0;
			$bNeg = $i < 0;
			$tmp = null;
			if($aNeg !== $bNeg) {
				$tmp = $aNeg;
			} else {
				$tmp = 32 > $i;
			}
			if(!$tmp) {
				break;
			}
			$v = "0" . _hx_string_or_null($v);
			$i = $i + 1;
			unset($tmp,$bNeg,$aNeg);
		}
		$int = $skip;
		$i1 = null;
		if($int < 0) {
			$i1 = 4294967296.0 + $int;
		} else {
			$i1 = $int + 0.0;
		}
		$int1 = 8;
		$i2 = null;
		if($int1 < 0) {
			$i2 = 4294967296.0 + $int1;
		} else {
			$i2 = $int1 + 0.0;
		}
		$i = Std::int(_hx_mod($i1, $i2));
		$r = "";
		while(true) {
			$aNeg1 = 8 < 0;
			$bNeg1 = $i < 0;
			$tmp1 = null;
			if($aNeg1 !== $bNeg1) {
				$tmp1 = $aNeg1;
			} else {
				$tmp1 = 8 > $i;
			}
			if(!$tmp1) {
				break;
			}
			$r1 = _hx_substr($v, $i * 4, 4);
			$r2 = null;
			$i = $i + 1;
			$a = $i;
			$aNeg2 = 8 < 0;
			$bNeg2 = $a < 0;
			$r3 = null;
			if($aNeg2 !== $bNeg2) {
				$r3 = $aNeg2;
			} else {
				$r3 = 8 > $a;
			}
			if($r3) {
				$r2 = " ";
			} else {
				$r2 = "";
			}
			$r = _hx_string_or_null($r) . _hx_string_or_null((_hx_string_or_null($r1) . _hx_string_or_null($r2)));
			unset($tmp1,$r3,$r2,$r1,$bNeg2,$bNeg1,$aNeg2,$aNeg1,$a);
		}
		return $r;
	}
	static function FLength($hash) {
		$count = 0;
		while(true) {
			$aNeg = $hash < 0;
			$bNeg = 0 < 0;
			$tmp = null;
			if($aNeg !== $bNeg) {
				$tmp = $aNeg;
			} else {
				$tmp = $hash > 0;
			}
			if(!$tmp) {
				break;
			}
			$hash = $hash & $hash - 1;
			$count = $count + 1;
			unset($tmp,$bNeg,$aNeg);
		}
		return $count;
	}
	function __toString() { return $this->toString(); }
}
function sirius_tools_Flag_0(&$_gthis, $v) {
	{
		$_gthis->put(1 << $v);
	}
}
function sirius_tools_Flag_1(&$_gthis, $v) {
	{
		$_gthis->drop(1 << $v);
	}
}
function sirius_tools_Flag_2(&$_gthis, $v) {
	{
		return !$_gthis->test($v);
	}
}
function sirius_tools_Flag_3(&$_gthis, &$min, $v) {
	{
		if($_gthis->test($v)) {
			$min = $min - 1;
		}
		return $min === 0;
	}
}
